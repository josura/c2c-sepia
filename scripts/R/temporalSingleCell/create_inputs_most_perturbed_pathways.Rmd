---
title: "test"
---

```{r}
library(CellChat)
library(Seurat)
library(readr)
library(Matrix)
```

```{r}
#the nodes file has the following columns separated by \t: Id	Name	Type	Aliases
nodesInfoFile <- "~/Projects/ccc/datiIdo/inputs/mmu_metapathway/nodes_mmu.txt"
# the map file contains the mapping between nodes and pathway names, has the format: PathwayId	PathwayName	EdgeStart	EdgeEnd
pathwayInfoFile <- "~/Projects/ccc/datiIdo/inputs/mmu_metapathway/map_mmu.txt"
#the edges file has the following columns separated by \t: Source	Target	Type	Subtype	Weight
metapathwayEdgesFile <- "~/Projects/ccc/datiIdo/inputs/mmu_metapathway/edges_mmu.txt"

```

```{r}
nodesinfo <- read_tsv(nodesInfoFile)

# create map that maps The Id in nodesInfoFile to the Name in nodesInfoFile, this map will be used to change the source and target in the metapathwayEdgesFile
nodesInfoMap <- nodesinfo %>% select(Id, Name) %>% as.data.frame()
nodesInfoMap <- nodesInfoMap[!duplicated(nodesInfoMap$Id),]
rownames(nodesInfoMap) <- nodesInfoMap$Id
nodesInfoMap$Id <- NULL

```

```{r}

metaPathwayEdges <- read_tsv(metapathwayEdgesFile)
#change the entrez IDs of the sources and the target to the gene names
metaPathwayEdges$Source <- nodesInfoMap[as.character(metaPathwayEdges$Source),]
metaPathwayEdges$Target <- nodesInfoMap[as.character(metaPathwayEdges$Target),]
# remove duplicate rows on source,target and weight values
metaPathwayEdges <- metaPathwayEdges[!duplicated(metaPathwayEdges),]
# remove edges with weight equal to 0
metaPathwayEdges <- metaPathwayEdges[metaPathwayEdges$Weight != 0,]

```

```{r}
pathwayInfo <- read_tsv(pathwayInfoFile)
# substitute EdgeStart and EdgeEnd with its related names using the nodesInfoMap

pathwayInfo$EdgeStart <- nodesInfoMap[as.character(pathwayInfo$EdgeStart),]
pathwayInfo$EdgeEnd <- nodesInfoMap[as.character(pathwayInfo$EdgeEnd),]

# remove duplicate rows on source,target and weight values
pathwayInfo <- pathwayInfo[!duplicated(pathwayInfo),]
```
## create map of pathways, where each pathway is mapped to a list of nodes/geneNames, no duplicates
```{r}
pathwayMap <- pathwayInfo %>% group_by(PathwayId) %>% summarise(geneNames = list(unique(c(EdgeStart, EdgeEnd))))

```
## compute the average expression of each gene in each pathway for a specific cell type
### function to compute the average expression
```{r}
computeAverageExpression <- function(seurat.obj, pathwayGenes, cellType){
  # get the average expression of each gene in the pathway for the specific cell type
  pathwayGeneExpressionToSpecificCellType <- seurat.obj[rownames(seurat.obj) %in% pathwayGenes,seurat.obj$cell_type == cellType]
  # the average will be computed for each cell type, not for each cell, meaning that the average will be the sum of the expression of the genes in the pathway across a single cell type divided by the number of cells in that cell type * number of genes in the pathway
  pathwayGeneExpressionAverage <- sum(pathwayGeneExpressionToSpecificCellType@assays$RNA@layers$counts)/length(pathwayGeneExpressionToSpecificCellType@assays$RNA@layers$counts)
  return(pathwayGeneExpressionAverage)
}
 
```
## compute perturbation for all the pathways
```{r}
# load the data from seurat.obj
seurat.obj.1h <- readRDS("~/Projects/ccc/datiIdo/seurat_obj.1h.rds")
cellTypes <- unique(seurat.obj.1h$cell_type)
```
### compute the average perturbation
```{r}
# get the average expression of each gene in each pathway for a specific cell type
averageExpressionsPerCellTypeAndPathway <- data.frame(data.frame(matrix(ncol=length(cellTypes),nrow=0)))
for (i in 1:length(pathwayMap$PathwayId)){
  pathwayAveragesList <- list()
  columnIndex <- 1
  for (cellType in cellTypes){
    pathwayAveragesList[[columnIndex]] <- computeAverageExpression(seurat.obj.1h, pathwayMap$geneNames[[i]],cellType)
    columnIndex <- columnIndex + 1
  }
  averageExpressionsPerCellTypeAndPathway <- rbind(averageExpressionsPerCellTypeAndPathway, pathwayAveragesList)  
}
colnames(averageExpressionsPerCellTypeAndPathway) <- cellTypes
rownames(averageExpressionsPerCellTypeAndPathway) <- pathwayMap$PathwayId
averageExpressionsPerCellTypeAndPathway$PathwayId <- pathwayMap$PathwayId
```
### save the average expressions in a file
```{r}
write.table(averageExpressionsPerCellTypeAndPathway, file = "/home/josura/Projects/ccc/datiIdo/averageExpressionsPerCellTypeAndPathway.tsv", sep = "\t", row.names = FALSE,quote = FALSE)
```
### load the average expressions from the file
```{r}
averageExpressionsPerCellTypeAndPathway <- read_tsv("/home/josura/Projects/ccc/datiIdo/averageExpressionsPerCellTypeAndPathway.tsv")
averageExpressionsPerCellTypeAndPathway <- data.frame(averageExpressionsPerCellTypeAndPathway)
```

### rank the pathways for every cell based on the average expression of the single pathway for the single cell type
```{r}
# for every cell type, rank the pathways based on the average expression and select the first 10
rankedPathwaysPerCellType <- list()
currentColumn <- 1
for (cellType in cellTypes){
  rankedPathwaysPerCellType[[cellType]] <- averageExpressionsPerCellTypeAndPathway[order(averageExpressionsPerCellTypeAndPathway[,currentColumn],decreasing = TRUE),]  %>% select(cellType, PathwayId) %>% head(40)
  currentColumn <- currentColumn + 1
    }
```

### save the ranked pathways in different files for each cell type
```{r}
dir.create("/home/josura/Projects/ccc/datiIdo/rankedPathways/1h", showWarnings = FALSE)
for (cellType in cellTypes){
  write.table(rankedPathwaysPerCellType[[cellType]], file = paste0("/home/josura/Projects/ccc/datiIdo/rankedPathways/1h/",cellType,".tsv"), sep = "\t", row.names = FALSE)
}
```

## create the input graph from the ranked pathways
### function to create the input graph
```{r}
#function to create the input graph
createInputGraph <- function(rankedPathwaysPerCellType, metaPathwayEdges, pathwayMap, cellType){
  # get the ranked pathways for the specific cell type
  rankedPathways <- rankedPathwaysPerCellType[[cellType]]
  # get the nodes of the ranked pathways
  nodes <- pathwayMap[pathwayMap$PathwayId %in% rankedPathways$PathwayId,] %>% select(geneNames) %>% unlist()
  nodes <- unique(nodes)
  # filter the edges in the metapathwayEdgesFile that have at least one of the nodes in the ranked pathways
  edges <- metaPathwayEdges[metaPathwayEdges$Source %in% nodes | metaPathwayEdges$Target %in% nodes,]
  return(edges)
}
```
### create the input graph for each cell type
```{r}
if(dir.exists("/home/josura/Projects/ccc/datiIdo/inputGraphs/1h") == FALSE){
  dir.create("/home/josura/Projects/ccc/datiIdo/inputGraphs/1h", showWarnings = FALSE)
}
if(dir.exists("/home/josura/Projects/ccc/datiIdo/inputGraphs/1h/graphs") == FALSE){
  dir.create("/home/josura/Projects/ccc/datiIdo/inputGraphs/1h/graphs", showWarnings = FALSE)
}
inputGraphs <- list()
for (cellType in cellTypes){
  inputGraphs[[cellType]] <- createInputGraph(rankedPathwaysPerCellType, metaPathwayEdges, pathwayMap, cellType)
  write.table(inputGraphs[[cellType]], file = paste0("/home/josura/Projects/ccc/datiIdo/inputGraphs/1h/graphs/",cellType,".tsv"), sep = "\t", row.names = FALSE)
}
```
### create the nodes for each cell type
```{r}
if(dir.exists("/home/josura/Projects/ccc/datiIdo/inputGraphs/1h/nodes") == FALSE){
  dir.create("/home/josura/Projects/ccc/datiIdo/inputGraphs/1h/nodes", showWarnings = FALSE)
}
for (cellType in cellTypes){
  nodes <- nodesinfo[nodesinfo$Name %in% unique(inputGraphs[[cellType]]$Source) | nodesinfo$Name %in% unique(inputGraphs[[cellType]]$Target),]
  write.table(nodes, file = paste0("/home/josura/Projects/ccc/datiIdo/inputGraphs/1h/nodes/",cellType,".tsv"), sep = "\t", row.names = FALSE,quote = FALSE)
}
```
# interaction inference
## load the cellChatDB
```{r}
CellChatDB <- CellChatDB.mouse # use CellChatDB.human if running on human data
showDatabaseCategory(CellChatDB)

# use a subset of CellChatDB for cell-cell communication analysis
CellChatDB.use <- subsetDB(CellChatDB, search = "Secreted Signaling", key = "annotation") # use Secreted Signaling
```
## prepare the data for the 1h timepoint
### prepare the seurat object by filtering the genes to the ones in the ranked pathways, as a single list to get all the interactions
### TODO: compute only the interactions that are possible with the node available in one graph related to a cell, that is for every couple (cellType1, cellType2) get the union of the nodes in the two graphs and compute the interactions only for the nodes in the union
```{r}
seurat.obj.1h.filtered <- seurat.obj.1h[rownames(seurat.obj.1h) %in% unique(unlist(pathwayMap$geneNames)),]


## initialize variables to be used for the interaction inference 
```{r}
seurat.obj.1h.filtered <- NormalizeData(seurat.obj.1h.filtered)
data.input <- seurat.obj.1h.filtered[["RNA"]]$data # normalized data matrix
Idents(seurat.obj.1h.filtered) <- "cell_type"
labels <- Idents(seurat.obj.1h.filtered)
meta <- data.frame(labels = labels, row.names = names(labels), samples = seurat.obj.1h.filtered@meta.data$Amp_batch_ID) # create a dataframe of the cell labels

cellchat <- createCellChat(object = data.input, meta = meta, group.by = "labels")
# set the used database in the object
cellchat@DB <- CellChatDB.use
# subset the expression data of signaling genes for saving computation cost
cellchat <- subsetData(cellchat) # This step is necessary even if using the whole database
future::plan("multisession", workers = 4) # do parallel

cellchat <- identifyOverExpressedGenes(cellchat,do.fast = FALSE)
cellchat <- identifyOverExpressedInteractions(cellchat)

# Compute the communication probability and infer cellular communication network
cellchat <- computeCommunProb(cellchat, type = "triMean")
## Users can filter out the cell-cell communication if there are only few cells in certain cell groups. By default, the minimum number of cells required in each cell group for cell-cell communication is 10.
cellchat <- filterCommunication(cellchat, min.cells = 8)
df.net <- subsetCommunication(cellchat)
# save the inferred cellular communication network as an object
saveRDS(df.net, file = "inputGraphs/1h/cellchat_inferred_network.1h.rds")
```
### loading the inferred network
```{r}
# load the inferred cellular communication network
df.net <- readRDS("cellchat_inferred_network.1h.rds")
```
## filter only the possible interactions between two cell types, considering the source and target nodes in the source and target graphs
